### Tupper 隐写

话不多说，直接上题（BUUCTF）

![](https://pic1.imgdb.cn/item/680b5ff458cb8da5c8cc1bfb.png)

下载附件给出了很多图片

![](https://pic1.imgdb.cn/item/680b604758cb8da5c8cc1dc9.png)

用脚本识别出来

```python
import ddddocr

ocr = ddddocr.DdddOcr()

for i in range(0,136):
     with open('{}.png'.format(i), 'rb') as f:
          img_bytes = f.read()
          tmp = ocr.classification(img_bytes).replace('o','0')
          print("".join(list(tmp)), end='')
```

查看提示给出了 Tupper

![](https://pic1.imgdb.cn/item/680b65cd58cb8da5c8cc3be1.png)

Jeff Tupper 的自引用公式（Tupper's self-referential formula）是 2001 年提出的一个著名数学公式，它在特定条件下绘制出的图形就是公式本身

这个公式展示了数学与计算机图形的奇妙联系，具有以下特点

原始不等式形式为：

```
1/2 < ⌊mod(⌊y/17⌋×2^(-17x-mod(y,17)),2)⌋
```

其中：

- ⌊·⌋ 表示向下取整函数
- mod 表示取模运算
- x 和 y 是坐标变量

**基本机制：**

- 公式定义了一个位图编码系统，可以将任何 106 像素宽 × 17 像素高的二值图像编码为一个超大整数 k
- 当在 0 ≤ x < 106 和 k ≤ y < k+17 的范围内绘制满足不等式的点时，就会重现编码的图像
- 神奇的是，当 k 取特定值时，绘制出的图像就是公式本身的不等式形式

**编码原理：**

1. 像素网格：将图像视为 17 行(高) × 106 列(宽)的网格
2. 二进制编码：
   - 每列 17 个像素可以看作 17 位二进制数（从下到上）
   - 将 106 列这样的 17 位数连接起来，形成一个超长的二进制数
3. 转换为十进制：将这个二进制数转换为十进制，就得到了 k 值

**解码过程（即绘图过程）：**

1. 对于每个像素位置 (x,y)（x∈[0,105], y∈[k,k+16]）
2. 计算`v = ⌊y/17⌋ × 2^(-17x - mod(y,17))`
3. 判断 mod(v,2) 是否大于 1/2
4. 如果满足，则在 (x,y-k) 位置绘制一个点

上脚本

```python
import numpy as np
import matplotlib.pyplot as plt


def Tupper_self_referential_formula(k):
    aa = np.zeros((17, 106))

    def f(x, y):
        y += k
        a1 = 2 ** -(-17 * x - y % 17)
        a2 = (y // 17) // a1
        return 1 if a2 % 2 > 0.5 else 0

    for y in range(17):
        for x in range(106):
            aa[y, x] = f(x, y)

    return aa[:, ::-1]


k = 1594199391770250354455183081054802631580554590456781276981302978243348088576774816981145460077422136047780972200375212293357383685099969525103172039042888918139627966684645793042724447954308373948403404873262837470923601139156304668538304057819343713500158029312192443296076902692735780417298059011568971988619463802818660736654049870484193411780158317168232187100668526865378478661078082009408188033574841574337151898932291631715135266804518790328831268881702387643369637508117317249879868707531954723945940226278368605203277838681081840279552
aa = Tupper_self_referential_formula(k)
plt.figure(figsize=(15, 10))
plt.imshow(aa, origin='lower')
plt.gca().invert_xaxis() # 这里发现图像是倒着的，需要反转
plt.show()
```

